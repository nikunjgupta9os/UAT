import * as XLSX from "xlsx";
import { saveAs } from "file-saver";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";

// Corporate color scheme
const CORPORATE_COLORS = {
  primary: "#1A4E7F", // Deep corporate blue
  secondary: "#2D7DB3", // Medium blue
  accent: "#E6F1FA", // Light blue background
  light: "#F5F9FD", // Very light blue
  dark: "#0A2E4D", // Dark blue for text
  white: "#FFFFFF",
  border: "#CCDDE9" // Light border
};

// Helper to get user email from localStorage
function getUserEmail(): string {
  if (typeof window !== "undefined" && window.localStorage) {
    return localStorage.getItem("userEmail") || "Kanav Arora";
  }
  return "Kanav Arora";
}

function formatDateDDMonYYYY(val: string): string {
  const d = new Date(val);
  if (isNaN(d.getTime())) return "";
  const day = String(d.getDate()).padStart(2, "0");
  const month = d.toLocaleString("en-US", { month: "short" });
  const year = d.getFullYear();
  return `${day}-${month}-${year}`;
}

function formatAmount(val: number | string): string {
  const num = Number(val);
  if (isNaN(num)) return String(val);
  return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function formatRate(val: number | string): string {
  const num = Number(val);
  if (isNaN(num)) return String(val);
  return num.toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 });
}

function formatRowForExport(row: any, headers: string[]): any {
  const formatted: any = {};
  headers.forEach((h) => {
    let val = row[h];
    if (typeof val === "string" && /^\d{4}-\d{2}-\d{2}/.test(val)) {
      formatted[h] = formatDateDDMonYYYY(val);
    } else if (h.toLowerCase().includes("amount")) {
      formatted[h] = formatAmount(val);
    } else if (h.toLowerCase().includes("rate")) {
      formatted[h] = formatRate(val);
    } else {
      formatted[h] = val;
    }
  });
  return formatted;
}

export const exportToExcel = (
  data: any[], 
  filename: string, 
  options?: { fxType?: string }
): void => {
  try {
    const fxType = options?.fxType;
    const title = fxType ? `FX ${fxType} Report` : "FX Report";
    const today = new Date();
    const dateString = today.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
    const userEmail = getUserEmail();

    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet([]);
    
    if (!data || data.length === 0) {
      XLSX.utils.book_append_sheet(workbook, worksheet, "Report");
      const excelBuffer = XLSX.write(workbook, { bookType: "xlsx", type: "array" });
      const blob = new Blob([excelBuffer], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });
      saveAs(blob, `${filename}.xlsx`);
      return;
    }

    const headers = Object.keys(data[0]);
    
    // Prepare worksheet data with header rows
    const worksheetData = [
      [title],
      [`Date: ${dateString}    Total Records: ${data.length}    Generated by: ${userEmail}`],
      [],
      headers,
      ...data.map(row => headers.map(h => row[h])),
    ];

    // Convert array of arrays to worksheet
    XLSX.utils.sheet_add_aoa(worksheet, worksheetData);
    
    // Set column widths
    const colWidths = headers.map(header => {
      const headerLength = header.length;
      const maxContentLength = Math.max(
        ...data.map(row => 
          row[header] ? String(row[header]).length : 0
        )
      );
      return { wch: Math.min(30, Math.max(12, Math.max(headerLength, maxContentLength) + 2)) };
    });
    worksheet['!cols'] = colWidths;
    
    // Set row heights
    worksheet['!rows'] = [
      { hpx: 30 }, // Title row height
      { hpx: 20 }, // Info row height
      { hpx: 5 },  // Spacer row height
      { hpx: 25 }, // Header row height
      ...data.map(() => ({ hpx: 20 })) // Data rows height
    ];
    
    // Add merges for title and info rows
    worksheet['!merges'] = [
      { s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }, // Title row
      { s: { r: 1, c: 0 }, e: { r: 1, c: headers.length - 1 } }  // Info row
    ];
    
    // Apply styles
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    
    for (let R = range.s.r; R <= range.e.r; ++R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cell_address = { c: C, r: R };
        const cell_ref = XLSX.utils.encode_cell(cell_address);
        
        if (!worksheet[cell_ref]) continue;
        
        // Title row (row 0)
        if (R === 0) {
          worksheet[cell_ref].s = {
            font: { 
              name: "Calibri", 
              sz: 16, 
              bold: true, 
              color: { rgb: CORPORATE_COLORS.white.replace("#", "") } 
            },
            fill: { 
              fgColor: { rgb: CORPORATE_COLORS.primary.replace("#", "") } 
            },
            alignment: { 
              horizontal: "center", 
              vertical: "center",
              wrapText: true 
            }
          };
        }
        // Info row (row 1)
        else if (R === 1) {
          worksheet[cell_ref].s = {
            font: { 
              name: "Calibri", 
              sz: 10, 
              italic: true, 
              color: { rgb: CORPORATE_COLORS.dark.replace("#", "") } 
            },
            fill: { 
              fgColor: { rgb: CORPORATE_COLORS.accent.replace("#", "") } 
            },
            alignment: { 
              horizontal: "center", 
              vertical: "center" 
            }
          };
        }
        // Header row (row 3)
        else if (R === 3) {
          worksheet[cell_ref].s = {
            font: { 
              name: "Calibri", 
              sz: 11, 
              bold: true, 
              color: { rgb: CORPORATE_COLORS.white.replace("#", "") } 
            },
            fill: { 
              fgColor: { rgb: CORPORATE_COLORS.secondary.replace("#", "") } 
            },
            alignment: { 
              horizontal: "center", 
              vertical: "center" 
            },
            border: {
              top: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } },
              bottom: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } },
              left: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } },
              right: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } }
            }
          };
        }
        // Data rows
        else if (R > 3) {
          const dataRow = data[R - 4];
          
          // Group header styling
          if (dataRow && dataRow.__rowType === "groupHeader") {
            worksheet[cell_ref].s = {
              font: { 
                name: "Calibri", 
                sz: 12, 
                bold: true, 
                color: { rgb: CORPORATE_COLORS.white.replace("#", "") } 
              },
              fill: { 
                fgColor: { rgb: CORPORATE_COLORS.primary.replace("#", "") } 
              },
              alignment: { 
                horizontal: "left", 
                vertical: "center" 
              }
            };
          } 
          // Subtotal styling
          else if (dataRow && dataRow.__rowType === "subtotal") {
            worksheet[cell_ref].s = {
              font: { 
                name: "Calibri", 
                sz: 11, 
                bold: true, 
                color: { rgb: CORPORATE_COLORS.dark.replace("#", "") } 
              },
              fill: { 
                fgColor: { rgb: CORPORATE_COLORS.accent.replace("#", "") } 
              },
              alignment: { 
                horizontal: "right", 
                vertical: "center" 
              },
              border: {
                top: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } },
                bottom: { style: "double", color: { rgb: CORPORATE_COLORS.primary.replace("#", "") } }
              }
            };
          } 
          // Regular data rows
          else {
            const isEvenRow = (R - 4) % 2 === 0;
            worksheet[cell_ref].s = {
              font: { 
                name: "Calibri", 
                sz: 10, 
                color: { rgb: CORPORATE_COLORS.dark.replace("#", "") } 
              },
              fill: { 
                fgColor: { 
                  rgb: (isEvenRow 
                    ? CORPORATE_COLORS.white.replace("#", "") 
                    : CORPORATE_COLORS.light.replace("#", "")
                  )
                } 
              },
              alignment: { 
                horizontal: "left", 
                vertical: "center" 
              },
              border: {
                bottom: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } },
                right: { style: "thin", color: { rgb: CORPORATE_COLORS.border.replace("#", "") } }
              }
            };
            
            // Right-align numeric columns
            const headerName = headers[C].toLowerCase();
            if (headerName.includes("amount") || headerName.includes("rate") || headerName.includes("value")) {
              worksheet[cell_ref].s.alignment = { 
                horizontal: "right", 
                vertical: "center" 
              };
            }
          }
        }
      }
    }

    // Freeze panes (headers and first column)
    worksheet['!freeze'] = { x: 1, y: 4 };

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, "Report");

    // Generate and save file
    const excelBuffer = XLSX.write(workbook, {
      bookType: "xlsx",
      type: "array",
      cellStyles: true,
    });

    const blob = new Blob([excelBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });

    saveAs(blob, `${filename}.xlsx`);
  } catch (error) {
    console.error("Excel export error:", error);
    alert("Failed to export Excel file. Please try again.");
  }
};

export const exportToPDF = (
  data: any[],
  filename: string,
  columns: any[],
  fxType?: string
): void => {
  try {
    const doc = new jsPDF('landscape');
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 14;

    const title = fxType ? `FX ${fxType} Report` : 'FX Report';
    const today = new Date();
    const dateString = today.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
    const userEmail = getUserEmail();

    // Title section with corporate styling
    doc.setFillColor(
      parseInt(CORPORATE_COLORS.primary.slice(1, 3), 16),
      parseInt(CORPORATE_COLORS.primary.slice(3, 5), 16),
      parseInt(CORPORATE_COLORS.primary.slice(5, 7), 16)
    );
    doc.rect(0, 0, pageWidth, 24, 'F');
    
    // Title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.setTextColor(255, 255, 255);
    doc.text(title, pageWidth / 2, 12, { align: 'center' });
    
    // Metadata section
    doc.setFillColor(
      parseInt(CORPORATE_COLORS.accent.slice(1, 3), 16),
      parseInt(CORPORATE_COLORS.accent.slice(3, 5), 16),
      parseInt(CORPORATE_COLORS.accent.slice(5, 7), 16)
    );
    doc.rect(0, 24, pageWidth, 10, 'F');
    
    doc.setFont("helvetica", "normal");
    doc.setFontSize(9);
    doc.setTextColor(
      parseInt(CORPORATE_COLORS.dark.slice(1, 3), 16),
      parseInt(CORPORATE_COLORS.dark.slice(3, 5), 16),
      parseInt(CORPORATE_COLORS.dark.slice(5, 7), 16)
    );
    
    doc.text(`Date: ${dateString}`, margin, 29);
    doc.text(`Total Records: ${data.length}`, pageWidth / 2, 29, { align: 'center' });
    doc.text(`Generated by: ${userEmail}`, pageWidth - margin, 29, { align: 'right' });

    // Prepare table data
    const headers = columns.map(col => col.id);
    const displayHeaders = columns.map(col => col.name || col.id);

    const body = data.map(row => 
      headers.map(h => {
        let val = row[h];
        
        // Format values based on column type
        if (typeof val === "string" && /^\d{4}-\d{2}-\d{2}/.test(val)) {
          return formatDateDDMonYYYY(val);
        } else if (h.toLowerCase().includes("amount")) {
          return formatAmount(val);
        } else if (h.toLowerCase().includes("rate")) {
          return formatRate(val);
        }
        return val;
      })
    );

    // Generate table
    autoTable(doc, {
      startY: 36,
      head: [displayHeaders],
      body: body,
      theme: 'grid',
      headStyles: {
        fillColor: [
          parseInt(CORPORATE_COLORS.secondary.slice(1, 3), 16),
          parseInt(CORPORATE_COLORS.secondary.slice(3, 5), 16),
          parseInt(CORPORATE_COLORS.secondary.slice(5, 7), 16)
        ],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
        fontSize: 10,
        cellPadding: 3,
        lineWidth: 0.1,
        lineColor: [255, 255, 255]
      },
      bodyStyles: {
        fontSize: 9,
        cellPadding: 2,
        lineWidth: 0.1,
        lineColor: [
          parseInt(CORPORATE_COLORS.border.slice(1, 3), 16),
          parseInt(CORPORATE_COLORS.border.slice(3, 5), 16),
          parseInt(CORPORATE_COLORS.border.slice(5, 7), 16)
        ]
      },
      alternateRowStyles: {
        fillColor: [
          parseInt(CORPORATE_COLORS.light.slice(1, 3), 16),
          parseInt(CORPORATE_COLORS.light.slice(3, 5), 16),
          parseInt(CORPORATE_COLORS.light.slice(5, 7), 16)
        ]
      },
      margin: { top: 36, left: margin, right: margin },
      styles: {
        font: "helvetica",
        fontSize: 9,
        cellPadding: 3,
        overflow: 'linebreak',
        halign: 'left',
        valign: 'middle'
      },
      columnStyles: {
        // Right-align numeric columns
        ...Object.fromEntries(
          headers.map((header, idx) => {
            const headerName = header.toLowerCase();
            if (headerName.includes("amount") || headerName.includes("rate") || headerName.includes("value")) {
              return [idx, { halign: 'right' }];
            }
            return [idx, {}];
          })
        )
      },
      didParseCell: function(data) {
        // Style group headers
        if (data.row.raw && (data.row.raw as any).__rowType === "groupHeader") {
          Object.assign(data.cell.styles, {
            fillColor: [
              parseInt(CORPORATE_COLORS.primary.slice(1, 3), 16),
              parseInt(CORPORATE_COLORS.primary.slice(3, 5), 16),
              parseInt(CORPORATE_COLORS.primary.slice(5, 7), 16)
            ],
            textColor: [255, 255, 255],
            fontStyle: 'bold',
            fontSize: 11
          });
        }
        // Style subtotals
        else if (data.row.raw && (data.row.raw as any).__rowType === "subtotal") {
          Object.assign(data.cell.styles, {
            fillColor: [
              parseInt(CORPORATE_COLORS.accent.slice(1, 3), 16),
              parseInt(CORPORATE_COLORS.accent.slice(3, 5), 16),
              parseInt(CORPORATE_COLORS.accent.slice(5, 7), 16)
            ],
            textColor: [
              parseInt(CORPORATE_COLORS.dark.slice(1, 3), 16),
              parseInt(CORPORATE_COLORS.dark.slice(3, 5), 16),
              parseInt(CORPORATE_COLORS.dark.slice(5, 7), 16)
            ],
            fontStyle: 'bold',
            fontSize: 10
          });
          
          // For subtotal rows, make the first cell say "Subtotal"
          if (data.column.index === 0) {
            data.cell.text = ["Subtotal"];
          }
        }
      },
      didDrawPage: function(data) {
        // Footer
        doc.setFontSize(8);
        doc.setTextColor(100, 100, 100);
        
        // Page number
        doc.text(
         `Page ${data.pageNumber} of ${doc.getNumberOfPages()}`,
          pageWidth / 2,
          doc.internal.pageSize.height - 10,
          { align: 'center' }
        );
        
        // Generation info
        doc.text(
          `Generated by ${userEmail} on ${dateString}`,
          margin,
          doc.internal.pageSize.height - 10
        );
      }
    });

    // Save the PDF
    doc.save(`${filename}.pdf`);
  } catch (error) {
    console.error("PDF export error:", error);
    alert("Failed to export PDF. Please try again.");
  }
};

export { formatRowForExport, formatAmount, formatRate };
